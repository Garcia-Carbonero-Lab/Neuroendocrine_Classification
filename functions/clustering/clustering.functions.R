
# Functions to genearte molecular classification

#function: clustering.ensemble
#input:
#      mod: MOFA model
#       factors.rm: vector with factors to remove from the model 
#      algorithms: vector with algorithms to use
#      outdir : path to write the results
#      scale: True or False if data should be scaled 

#output:similarity matrix for each k and algorithm

#description: function to create the similarity matrix for each k and algorithm

clustering.ensemble <- function(mod,
factors.rm,
algorithms,
outdir,
scale = F){

Z <- obtain_Z(mod)
Z <- Z[, !colnames(Z) %in% factors.rm]


clust <- consensus_cluster(
    data = Z,
    nk = 2:6,
    p.item = 0.85,
    reps = 10000,
    algorithms = algorithms,
    distance = "spearman",
    scale = scale,
    type = "robust",
    file.name = paste0(outdir, "/consensus"),
    progress = T,
    seed.data = 134)

#input NA generated by patient boostraping
clust_input <- apply(clust, 2:4, impute_knn, data = Z, seed =1)

saveRDS(clust_input, paste0(outdir, "/clust_input.rds"))

#Create the similarity matrix for each k and algorithm
comb <- consensus_combine(clust_input, element = "matrix")


saveRDS(comb, paste0(outdir, "/comb.rds"))
}

# Functions to genearte molecular classification

#function: clustering.ensemble.matrix
#input:
#      mod: MOFA model
#      factors.rm: vector with factors to remove from the model 
#      k: numer of groups
#      clust_input: clustering object
#      outdir : path to write the results

#output: matrix with samples as rows and one column with he group of each sample
#description: function to obtain the group of each sample

clustering.ensemble.matrix <- function(mod, factors.rm, k,
clust_input, outdir) {

Z <- obtain_Z(mod)
Z <- Z[, !colnames(Z) %in% factors.rm]


outdir <- paste0(outdir)

#inputing the remaining issin cases

Ecomp <- impute_missing(clust_input, Z, nk = k)

print("obtaining consensus classes")

#Obtain consensus classes
CSPA <- CSPA(clust_input, k = k)

class.matrix <- data.frame(
    "Subtype" = CSPA,
    row.names = rownames(Z)
)

write.table(class.matrix,
paste0(outdir, "/Class.matrix_", k, ".txt"),
sep = "\t",
row.names = T,
col.names = NA)

return(class.matrix)
}


#function: heatmap_classes
#input:
#      Z: matrix with sampels in rows and factors in columns
#     base vector with factors to remove from the model 
#      outdir : path to write the results.
#      col: list indicating the color of each klevel in each feature
#      size: vector indicating the width and height of the pdf
#      factors.rm: factors to remove
#      anot_param_gegend: list indicating the list of legend parameter
#      anot_h: list idicating the anotation information
#      column: column to split heatmap
#      flag: name to add to files
#     

#output: heatmap spliting by suptypes anoatted with clinical data with fators as
# rows and samples as columns
#description: function to obtain the heatmap of subtypes and factors

heatmap_classes <- function(Z,
base,
outdir,
col,
size,
factors.rm,
anot_param_legend,
anot_h,
column,
flag) {
    
Z <- Z[, !colnames(Z) %in% factors.rm]

Z <- Z[base$sample,]
data <- t(Z)
data <- zscore.rows2(data)

anot <- base[, names(col)]


ha_column <- HeatmapAnnotation(
            df = anot,
            show_legend = T,
            col = col,
            annotation_name_gp = gpar(fontsize = 60),
            border = unit(40, "cm"),
            annotation_height = anot_h,
            height = unit(20, "cm"),
            gp = gpar(fontsize = 80),
            simple_anno_size_adjust = TRUE,
            annotation_legend_param = anot_param_legend)


hm1 <- Heatmap(as.matrix(data),
            top_annotation = ha_column,
            show_row_names = T,
            show_column_names = F,
            col = colorRamp2(
                c(max(data), 0, min(data)),
                c("red", "white", "blue")
            ),
            gap = unit(5, "mm"),
            cluster_rows = T,
            show_row_dend = F,
            show_column_dend = F,
            column_dend_side = "top",
            column_dend_height = unit(6, "cm"),
            cluster_columns = T,
            clustering_distance_rows = "pearson",
            clustering_distance_columns = "pearson",
            heatmap_legend_param = list(
                title = "Z score (Factor)",
                title_position = "topcenter",
                legend_direction = "horizontal",
                title_gp = gpar(fontsize = 60),
                labels_gp = gpar(fontsize = 60,
                family = "Times", face = "bold"),
                legend_width = unit(30, "cm"),
                grid_height = unit(2.5, "cm")
            ),
            row_names_side = "left",
            row_names_gp = gpar(fontsize = 100),
            column_split = anot[, column],
            cluster_column_slices = FALSE
        )

hlist <- hm1

p <- draw(hlist, heatmap_legend_side = "bottom",
        annotation_legend_side = "top",
        padding = unit(c(20, 240, 20, 20), "mm"))

pdf(paste0(
            outdir, "/Heatmap_anotated_", flag, ".pdf"
        ),
        width = size[["width"]], size[["height"]]
        )
        print(p)
        dev.off()

}




#function: coph.plot
#input:
#     coph: named vector indicating the cophenetic number for each k
#     outdir: path to write the cophenetic plot 
#     

#output: coephenetic plot indicating the coephenetic value for each k
#description: function to obtain the coepehentic heatmap.

coph.plot <- function(coph, outdir){

k <- as.numeric(names(coph))

outdir <- paste0(outdir)

df <- data.frame(k = k, cophenetic.correlation = coph)

plt <- ggplot(data=df, aes(x=k, y=cophenetic.correlation)) +
  geom_line()+
  geom_point() + 
  theme_classic() +
  theme(text = element_text(size = 18))

ggsave(
            plot = plt, filename = paste0(
            outdir, "/Cophenetic.pdf"
        ),
            device = "pdf",
            dpi = 500, width = 5,
            height = 5
        )


}